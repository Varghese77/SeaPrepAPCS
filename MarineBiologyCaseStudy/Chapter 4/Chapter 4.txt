Roy MathewChapter 4 QuestionsApril 1st 2015Uploaded ~5:00 p.mAnalysis Question Set 1:	1. The way the code is set up now, the nextLocation will only allow the DarterFish to move forward and this will cause it to never change direction and thus stop moving at the edge of the environment. In addition, it doesn't account for there being an obstacle in the square directly in front of it but not two tiles in front. 	2. There could be a changeDirection method that generates a random number to use as a low probability for changing the direction field that is called before nextNeighbor. Exercise Set 1:	1. Uploaded as Chapter 4 Exercise Set 1 Problem 1 Diagrams.png.	2. DarterFish move two tiles in front if there is no obstruction or otherwise one tile in front if possible, else it reverses direction. The normal fish then exhibit their same behavior of moving on a random direction in front or to the side but also making sure not to collide with any other objects or boundaries. 	3. Somehow even using the same seed (17), the fish movements are different. This leads me to think that taking out the breeding and dying methods also changed how the random number generator uses seeds and thus different numbers were used. DarterFish data files were also saved. 	4. The original fish class from chapter 2 was used as suggested by the instructions, thus no new constructors are needed for the DarterFish class. 	5. toString method added in DarterFish.	6. When a different seed is used, the DarterFish move and behave in the same way but regular fish do not move in the same way. 	7. TurningDarter subclass created. Analysis Question Set 2:	1. The benefits of putting the test of whether to move in the nextLocation method is that any code that wants to call on that specific piece of code only needs to call the method to get the location of where to move the fish. In order to avoid code reuse, this is probably the best way of doing it. The drawback of this method is that it means next location is doing two actions (determining probability and actually generating the location to move) so in this sense someone could say that it is organized poorly.  The same benefits and drawback don't apply if the fish would change direction because in this case the next location method would not only mutate location but also direction and this behavior is too much for the expected scope of the method.  	2. Because the instance variables are private and not protected, this prevents any subclass from being able to access or mutate these variables and thus it is impossible to use or change them outside of what was defined in the specific class that they were defined in. 	3. protected so that subclasses can also use them. Analysis Question Set 3:	1. The benefit to this drawback is that fish's original behavior is preserved while a new object can be used to represent the new behavior thus there can be some fish that breed and die while others don't. The drawback to this idea is that is not needed as the probability of both breeding and dying can both be set to 0 and have the same effect thus doing this makes the program more complex than it needs to be. These effects would also affect DarterFish and SlowFish because they would only generate children or die depending on which fish object they inherited from thus if the user wanted some DarterFish that made children with others that don't, there would need to be two different types of DarterFish objects and this could make the program more complex than it needs to be. 	2. The DarterFish nextLocation is deterministic while the Fish and SlowFish nextLocation method is probabilistic  because they both use random numbers. Exercise Set 2:	1. The Fish class used is the same as in chapter 2 as suggested by the instructions, thus no new constructors were added and no new constructors need to be added to SlowFish. 	2. The SlowFish only move every once in a while in a random direction while the normal fish moves every step in a random direction. This was expected. 	3. toString Method updated.	4. Changing the seed the data files changes the movements that each fish has but the behavior is still what is expected. 	5. 14.5 percent (76 / 523) of SlowFish attempted to breed, which is consistent with the 1 / 7 probability which is 14.2 percent.  The total fish actions should equal the number of times move was called plus the number of total times a fish would breed which is (459 + 64 = 523), thus move was called the correct number of times. nextLocation is called the same amount of times move is called in SlowFish, thus over the 20 time steps it was called 459 times in Slow Fish. In regular Fish, it was called each time the Fish attempted to actually move which would mean that the Fish nextLocation was called 94 times. The percent of fish that did not breed that attempted to move past their own cell was 20.4 percent (94 / 459) and that means that 79.6 percent moved to slowly to even attempt this. This is very close to the expected 20 percent and 80 percent. 18.3 percent of fish died (96 / 523) which is smaller than the expected 20 percent (1 / 5).  The results after 20 time steps are much closer to the expected results than after ten steps, and this is simply due to more trials and thus more quantitative data to derive calculations from. 	6. SlowFish updated. 	7. Fish subclass created	8. CircleFish Created	9. CircleFish Updated