Roy MathewChapter 2 Final Questions March 15th 20153:03 p.m. Analysis Set Questions 7:	1. In each environment, when the neighbors Of method is passed a (1,0) location as a parameter then it will return three locations which are (0,0),  (2,0) and (1,1). 	2. Environment 1 would return 1 empty neighbors, Environment 2 would return 1 empty neighbors, Environment 3 would return 2 empty neighbors, and Environment 4 would return 3 empty neighbors.	3. For Environment 1, nextLocation for the fish in location (1,0) could be no location because there is no viable square for the fish to move to and the fish can't move backwards.  For Environment 2, nextLocation for the fish in location (1,0) could be (1,1) because it is the only empty neighbor.  For Environment 3, nextLocation for the fish in location (1,0) could be (1,1) or (2,0) they are both valid empty locations.  For Environment 4 nextLocation for the fish in location (1,0) could be (0,0), (1,1) or (2,0). Analysis Question Set 8:	1. emptyNeighbors() will first call neighborsOf the location (2,2) to get all four neighbors. Then it will  use isEmpty() to create a new ArrayList of the empty neighbors (1,2), (2,3), and (2,1). The oppositeDir will be set to West pointing to (2,1) making that location not considered in nextLocation. Then a random number is generated from the two remaining locations (either 0 or 1) and that number is used as the index to return the fishï¿½s new location. The fish could now move to (1,2) or (2,3). 	2. The Fish object would need an age field that can be defined in initialize and modified by methods (by an accessor so that the fish's age can actually be accessible and a mutator so that each time the fish moves a method can be called to increment the value). This assumes that each step or movement is equal to an increase in 1.Exercise Set 4:	1. Fish class modified!	2. SimpleMBSDemo2 modified!Analysis Question Set 9:	1. There could be a fish in a location that is invalid. For instance in a 20 X 20 bounded environment a fish might be set to locations (30,30) or (-3,-3).	2. A test case that has a fish with three adjacent fish in front of it and to the sides but an empty neighbor behind the fish cover the embedded conditional statement in emptyNeighbors because the conditional statement takes an ArrayList of neighbors and then adds the ones that are empty to a new ArrayList. This test case will give emptyNeighbors an arrayList of neighbors and then the conditional statement in the loop will check to see if any of those neighbors are valid. 	3. An environment that is 1 row by 2 columns and have a fish in (0,0) facing east. Exercise Set 5:	1. When the seed was set to 8, and a fish was set to (1,1) in a 10X10 environment, the fish defaulted to light green facing east and moved right, up right and 	so on every time. This behavior changed when extra fish were added or the seed changed. 	2. The output shows the ID, location, and direction of each fish in this point of time when the simulation step function is running. 	3. Seed set to 1	Fish 1: (Initially (5, 5)North)	Step 1: (5, 4)West	Step 2: (5, 3)West	Step 3: (6, 3)South	Step 4: (6, 2)West	Step 5: (5, 2)North	Fish 2: (Initially (3, 3)South)	Step 1: (3, 2)West	Step 2: (3, 1)West	Step 3: (2, 1)North	Step 4: (1, 1)North	Step 5: (1, 2)East	Fish 3: (Initially (10, 10)West)	Step 1: (11, 10)South	Step 2: (11, 9)West	Step 3: (11, 8)West	Step 4: (10, 8)North	Step 5: (9, 8)North	Fish 4: (Initially (2,10)North)	Step 1: (3, 10)South	Step 2: (3, 11)East	Step 3: (4, 11)South	Step 4: (5, 11)South	Step 5: (5, 12)East	Fish 5: (Initially (1, 1)South)	Step 1: (1, 2)East	Step 2: (2, 2)South	Step 3: (3, 2)South	Step 4: (3, 3)East	Step 5: (2, 3)North	4. Data files created!	5. In order to move the fish, allObjects returns fish goes row by row (starting in the upper left corner and moving towards the lower right corner. This can be seen in set 6 (not shown above) where fish 2 moves to (1 ,3) effectively blocking fish 5 from going to that spot.  This order makes fish move before others and then possibly block the empty neighbor locations of fish that haven't moved yet. 	6. Noroom.dat tests a single fish being in a 1X1 bounded environment. It stays I the same place facing the same direction forever. 	7. To test move() and nextLocation(),  two test cases, one with no valid squares for the fish object to move to and one with at least one valid location for the fist to move to are needed.  To make it so that there are no squares to move to, the fish has to either have a boundary or fish on its side squares and in front of it. If there are no valid locations to move to then the fish will stay in place, else it will move to that location. To test emptyNeighbors two test cases are needed, a fish with no neighbors (ie 1X1 environment or a fish surrounded by other fish on al four sides), and a fish with at least one empty location in one of the four directions. In the first case emptyNeighbors will return a blank ArrayList and in the last case an ArrayList with the empty locations will be returned. Analysis Question Set 10	1. Scenario number 5 is closest to the actual structure of the program.	2. If scenario two were implemented, the simulation class would be responsible for getting an ArrayList of every object in the environment and having them act. It would need its own allObjects and which would get an arrayList off all objects the simulation is working on as well as numObjects, isEmpty and so on. Otherwise the fish lass would remain the same and all the environment needs to do is keep methods need display the updated results and not determine behavior.  	3. I think scenario number 2 makes the most sense (that isn't scenario 5) because it makes sense for a simulation object to be passed objects that it acts upon. Limiting the environment class to only maintaining information needed to present itself visually also helps organization better. It also helps keep most of the processing in the specific simulation object rather than in the fish or environment object. 	4. Scenario 4 is poorly organized because it lumps too much responsibility on the environment class. Each class should stick with one overall function however in scenario 4 it is given the tasks of tracking the fish, knowing what behavior the fish has, and how to move the fish. If this implementation were the case, then a separate fish object wouldn't even be needed and to an extent the simulation object wouldn't be needed because all the core functionality would be in the environment object. 	5. Yes. One example of a class that could be used in other applications is scenario 1 where all that is needed is for the application to pass other locatable objects to the simulation and have the simulation object act upon them presuming that the locatable objects know their own behavior.  An example of a class that couldn't be used in other application is the environment in scenario 4 is too specific to be used in any other program because it has very narrowly defined methods that operate for itself and it would be hard to come up with an application that effectively uses this class. 